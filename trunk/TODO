
- BUG: Handle JObject constructors that set fields
    - Currently get "Recursive load" error from CacheLoader

- Expression parsing
    - Make Value interface; add LValue sub-interface

- JTransaction convenience method for "static" index queries:

    public <V, T> NavigableMap<V, NavigableSet<T>> indexQuery(
      Class<T> startType, String fieldName, Class<V> valueType);

- Integrate CountingKVStore into KVStore, making it mandatory
    - Create AbstractKVStore, replacing CountingKVStoreAdapter

- Change terminology "snapshot" transaction -> "memory" transaction

- @OnChange, @OnCreate, @OnDelete:
    - Add boolean memoryTransactions() default false

- Consider renaming @IndexQuery "startType" to "type"

- Add @JFieldboolean cascadeDelete()

- Add @JField uniqueness constraints:
    - Field must be indexed (obviously)
    - boolean unique() default false
    - boolean uniqueDefault() default false
        - whether default value included
        - default value is NaN for float, double, otherwise normal default
    - boolean uniqueGlobal() default true
        - for simple fields: must be true, error otherwise
        - for collection sub-fields: whether constraint is per-object, or global
    - Verify in deferred manner as follows:
        - Add validation check for uniqueness
        - Register SimpleFieldChangeListener on affected fields
        - When listener invoked (or object created), enqueue object for validation
    - Note adding unique() in schema upgrade can create unchecked violations
    - For set element or map key sub-field, error if both uniqueDefault = false
      and uniqueGlobal = false, because this is redundant

- XMLKVDatabase
    - Provide subclass hook for a default initial XML database

- CLI
    - Support Comparable with < > <= >=
    - Aggregate functions: min(), max(), avg(), sum()

- Composite indexes on multiple fields?
    - @CompositeIndex(storageId = 123, fields = { 15, 16 })
    - public NavigableSet<?> queryIndex(int... storageId)

- Add Vaadin GUI editor generator

- Bug: if same simple field storage ID used in two different Java classes,
  an @IndexQuery on one could return sets containing instances of the other
  Fix: require method return type to have common ancestor as set element type.

- Ant task for easy validation of JLayer annotations during a build

- Reimplement LockManager using Guava ranges?
    - https://code.google.com/p/guava-libraries/wiki/RangesExplained

- More built-in field types:
    - BigInteger, BigDecimal
    - SimpleDateFormat
    - BitSet
    - InetAddress, Inet4Address, Inet6Address
    - {Gregorian}Calendar?
    - {Simple}TimeZone?

- Graceful recovery mode
    - If any inconsistent information encountered
        - Log an error
        - Return reasonable default

- <ReferenceField> restriction that limits storage ID of
  referenced object to the specified list ?

