
- Add support for XA transactions
    - But only if KVStore supports them

- Annotation enhancements:
    - Allow storageId's to default to zero; if so, auto-generate them:
        - Object type: hash object type name
        - Complex field: hash field name+field type (i.e., "list", "set", or "map")
        - Simple field: hash field name+field type
            - For sub-fields, name is "parent.element", "parent.key", or "parent.value"
        - Hash to a value in the range 0xfb-0x100fa (so max 3 bytes encoded)
    - @JSimpleClass: add autoProperties() default true
        - All bean properties not marked @JTransient are added automatically
    - @JSimpleClass: add abstract() default false
        - If true then no corresponding object type is generated
        - Alows autoProperties to work for subtypes without creating supertype

- Bug: JSimpleDB reference field's target type can change across schema
  versions, resulting in possible ClassCastExceptions at runtime.
    - Core API changes:
        - Add optional <ReferenceField> child tag <AllowedStorageIds> that limits
          storage IDs of referenced object to the specified list.
        - Enforce with IllegalReferenceException when:
            - Writing reference field
            - Upgrading object version
                - For collection fields, need to iterate only for un-indexed map value refs
    - JSimpleDB changes:
        - Add "plain" JObject class to represent objects in a prior schema version
          for which the current schema has no representing Java type
            - This class should not auto-upgrade object when fields accessed
        - ReferenceConverter: for unknown types, fallback to "plain" JObject instead
          of throwing exception
        - Generate schemas to include <AllowedStorageIds> list containing storage IDs
          of all object types that are sub-types of the reference's Java type
        - On every new JSimpleDB transaction:
            - For all reference fields:
                - Calculate union of all storage ID's possibly referenced by the reference
                  field in ALL schema versions (using <AllowedStorageIds> lists)
                - Ensure Java type of reference is super-type of all these
                    - For unknown prior schema version storage IDs, substitute JObject.class

- Build and distribute binary distribution
    - lib subdirectory with dependencies
    - add Main-Class and Classpath manifest headers to CLI and GUI jars
    - Example database and commands to run CLI and GUI
    - README's etc.

- Expression parsing
    - Aggregate functions: min(), max(), avg(), sum()

- Schema comparator
    - Shows only differences
    - New CLI command "schema-diff vers1 vers2"

- Transaction schema check
    - Add encoding version number to FieldType
    - Record encoding version in database schema

- Add new @JField property: boolean cascadeDelete()

- Add @JField uniqueness constraints:
    - Field must be indexed (obviously)
    - boolean unique() default false
    - boolean uniqueDefault() default false
        - whether default value included
        - default value is NaN for float, double, otherwise normal default
    - boolean uniqueGlobal() default true
        - for simple fields: must be true, error otherwise
        - for collection sub-fields: whether constraint is per-object, or global
    - Verify in deferred manner as follows:
        - Add validation check for uniqueness
        - Register SimpleFieldChangeListener on affected fields
        - When listener invoked (or object created), enqueue object for validation
    - Note adding unique() in schema upgrade can create unchecked violations
    - For set element or map key sub-field, error if both uniqueDefault = false
      and uniqueGlobal = false, because this is redundant

- Composite indexes on multiple fields?
    - @CompositeIndex(storageId = 123, fields = { 15, 16 })
    - public NavigableSet<?> queryIndex(int... storageId)

- Add Vaadin GUI editor generator

- Ant task for easy validation of JLayer annotations during a build

- Reimplement LockManager using Guava ranges?
    - https://code.google.com/p/guava-libraries/wiki/RangesExplained

- More built-in field types:
    - BigInteger, BigDecimal
    - SimpleDateFormat
    - BitSet
    - InetAddress, Inet4Address, Inet6Address
    - {Gregorian}Calendar?
    - {Simple}TimeZone?

- Graceful recovery mode
    - If any inconsistent information encountered
        - Log an error
        - Return reasonable default

- <ReferenceField> restriction that limits storage ID of
  referenced object to the specified list ?

