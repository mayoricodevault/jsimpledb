
- Add support for composite indexes on 3, 4, ... fields

- Add support for XA transactions
    - But only if KVStore supports them

- Expression parsing
    - Aggregate functions: min(), max(), avg(), sum()

- Schema comparator
    - Shows only differences
    - New CLI command "schema-diff vers1 vers2"

- FieldType UUID's
    - Add "encoding UUID" to FieldType
    - Record UUID in database schema
    - Verify on load

- Add new @JField property: boolean cascadeDelete() default false
    - Deletion of object causes deletion of referred-to object

- Add @JField uniqueness constraints:
    - Field must be indexed (obviously)
    - boolean unique() default false
    - String uniqueIgnore() default ""
        - optional value which is excepted from uniqueness constraint
        - for example "NaN" for float/double
    - boolean uniquePerObject() default false
        - for simple fields: must be false, error otherwise
        - for collection sub-fields: whether constraint is per-object, or global
    - Verify in deferred manner as follows:
        - Add validation check for uniqueness
        - Register SimpleFieldChangeListener on affected fields
        - When listener invoked (or object created), enqueue object for validation
    - Note: adding unique() in a schema upgrade can create unchecked violations
        - So just add updated objects to validation queue
    - Note: for set element or map key sub-fields, if uniqueIgnore() = ""
      and uniquePerObject() = true this is redundant

- Finish Vaadin GUI editor generator
    - Implement collection fields
    - Make more modular/pluggable

- Ant task for easy validation of JLayer annotations during a build

- Reimplement LockManager using Guava ranges?
    - https://code.google.com/p/guava-libraries/wiki/RangesExplained

- Reimplement LockManager using KeyRanges?

- More built-in field types:
    - BigInteger, BigDecimal
    - SimpleDateFormat
    - BitSet
    - InetAddress, Inet4Address, Inet6Address
    - {Gregorian}Calendar?
    - {Simple}TimeZone?

- Graceful recovery mode
    - If any inconsistent information encountered
        - Log an error
        - Return reasonable default

- Consistency checker
    - Checks a JDB key-value store for consistency
        - All field values are properly encoded
        - Object vs. index entry consistency
        - No extraneous key-value pairs exist
    - Uses another, empty database to store its state
        - Allows to run in multiple "chunked" transactions
    - Generates inconsistency report
    - Can auto-repair if necessary

